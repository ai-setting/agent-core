# Environment 设计理念：为 Agent 构建可交互的“运行时环境实体”

## 1. 我们想解决的问题

很多 Agent 框架把“运行时”隐含在若干零散组件里：prompt 拼接、工具列表、子代理、事件流、日志、权限、安全策略、会话状态……它们往往分布在不同模块，导致：

- **能力注入分散**：新增一个工具/技能/MCP 往往需要改多处，边界不清晰
- **运行形态难复用**：CLI / Server / 测试环境的差异容易侵入 Agent 核心逻辑
- **可观测性薄弱**：日志、事件、审计、可回放等能力缺少统一入口
- **可控性不足**：超时/并发/重试/权限等策略无法在一个层面统一实施

我们选择把“运行时”明确成一个一等实体：**Environment**。

## 2. 核心主张：Environment 是 Agent 的运行时上下文（且可交互）

在 Agent Core 中，**Environment 是 Agent 运行时的唯一上下文抽象**。它不仅是“配置容器”，更是一个可交互的环境实体，为 Agent 提供：

- **prompt**：system prompt / prompt 仓库 / 动态 prompt 构建
- **sub agents**：子代理的定义、路由与创建（同一套 Agent 逻辑在不同 Env 中呈现不同角色）
- **tools**：原生工具 + MCP 工具 + skills 工具的统一视图
- **mcp**：连接、发现、装配与生命周期管理（把外部能力变成 Env 的工具集一部分）
- **skills**：加载、注册与版本化（将经验/脚本/能力打包成可复用工具）
- **env 原生接口（native interfaces）**：运行日志、事件、审计、安全策略、取消/超时、并发限制、资源与工件管理等

一句话概括：

> **Agent 负责“想清楚做什么”，Environment 负责“在什么世界里、用什么能力、以什么约束去做”。**

## 3. 我们与常见 Agent 框架的关键不同点

### 3.1 Environment 是“世界”，不是“工具集合”

常见做法是把 tools 当作核心扩展点：给 Agent 一个工具列表，剩下的运行时能力由各处“拼起来”。  
我们的做法是把 tools 视为 Environment 的一部分，但不止于 tools。

**Environment 提供的统一入口**带来三个收益：

- **统一治理**：权限、超时、重试、并发、审计、脱敏等策略可在 Env 的执行入口统一落地
- **统一观测**：LLM 流、工具调用、子代理、资源变化等都能以事件形式被订阅/回放
- **统一复用**：Agent 核心逻辑不需要知道运行在 CLI / Server / Test，只依赖 Env 接口

### 3.2 Environment 把“可观测性”变成产品能力

在 Agent 时代，“运行日志/事件流/可回放”不是调试附属品，而是闭环能力（Agent 需要从环境反馈中修正计划、做恢复、给用户解释）。

因此我们把这些能力作为 Environment 的原生接口能力来设计，例如：

- **查看运行日志**：Env 提供查询/订阅运行日志的接口（给 Agent 或 UI）
- **产生事件并反馈**：Env 把 tool 生命周期、LLM streaming、错误、恢复动作等标准化为事件
- **审计与安全**：对敏感参数、文件路径、命令执行等做策略判断与记录

### 3.3 Environment 允许“同一 Agent 在不同世界里工作”

通过特化不同的 Environment（例如 CLI、本地 OS、服务端会话、多租户、测试沙箱），可以实现：

- 同一 Agent 逻辑复用
- 不同的 prompt、工具集、策略约束与观测通道
- 不同的“世界模型”（例如只读文件系统、带模拟网络、带配额限制等）

## 4. Environment 的职责边界（建议作为迭代开发的判断准则）

### 4.1 Agent 应该负责什么

- 任务理解、计划、推理与决策（例如是否调用工具、调用哪个工具、如何组织消息）
- 结构化输出与对用户的解释
- 在得到 Environment 反馈（事件、结果、错误）后进行调整与恢复

### 4.2 Environment 应该负责什么

- 一切 I/O 与外部交互的落地（文件/进程/网络/数据库/MCP/技能执行）
- 工具的注册、列举、执行入口与生命周期管理
- 安全策略与执行治理（权限、超时、并发、重试、审计、脱敏）
- 运行时可观测性（事件流、日志、指标/追踪、可回放/可复现）
- 不同运行形态的差异屏蔽（Server/CLI/Test）

> 经验法则：**当你在做“接入一种新能力/新边界约束/新运行形态”时，优先落在 Environment。**

## 5. 一个可交互 Environment 的能力清单（用于指导后续迭代）

以下不是一次性做完的“大全”，而是一个能持续迭代的路线图。每当需要扩展能力时，优先思考是否补全其中一项。

### 5.1 Prompt 与角色（Agent Specs）

- Prompt 仓库（按 `prompt_id` 管理）
- 动态 prompt 组装（结合 workdir、用户偏好、项目状态、策略约束）
- 多角色/多代理配置（不同 system prompt、不同模型偏好、不同工具白名单）

### 5.2 工具统一视图（Tools）

- 原生工具（如文件、shell、网络等）
- MCP 工具（来自外部 MCP server）
- Skills 工具（项目内/用户态技能）

要求：对 Agent 来说，这三者应呈现为 **同一种“工具”抽象**，并通过 Environment 的统一执行入口治理。

### 5.3 子代理（Sub-agents）

- 子代理的创建与运行由 Environment 统一编排（例如将子代理的工具权限缩小）
- 子代理输出、过程事件可被主 Agent/客户端订阅
- 用于并行探索、验证、长耗时任务分解等

### 5.4 事件与日志（Observability）

Environment 应能把关键过程标准化为事件（可订阅、可回放、可持久化）：

- LLM streaming（start/text/reasoning/completed/error/usage）
- tool 生命周期（tool_call/tool_result/error）
- 子代理生命周期（spawn/handshake/progress/completed/error）
- 策略决策（deny/allow、降级、重试、熔断等）

并提供面向 UI / Agent 的日志/事件接口，例如：

- “查看当前运行日志”
- “订阅当前任务事件流”
- “导出本次任务的可回放记录（replay）”

### 5.5 治理与安全（Control Plane）

建议逐步在 Environment 的执行入口沉淀：

- 超时、取消（AbortSignal / cancellation token）
- 并发与速率限制（per-tool / per-session / per-tenant）
- 权限模型（只读/读写/网络/进程）
- 审计与脱敏（尤其是 tool args、文件路径、token 等）

## 6. 运行时工作流（概念）

一个典型的工作流可以理解为：

1. 用户提出任务
2. Agent 在 Environment 提供的 prompt/工具/策略约束下推理与决策
3. Agent 通过 Environment 的统一入口执行工具/调用 LLM/派生子代理
4. Environment 将过程标准化为事件（日志/流）反馈给 Agent 与客户端
5. Agent 根据反馈调整策略，直到完成任务

> 关键点：**反馈通道属于 Environment**，而不是散落在工具实现或 UI 层。

## 7. 如何用这份理念指导“迭代开发”（落地检查表）

当你要做一个新功能/新能力时，优先按下面顺序落地：

- **抽象入口**：这件事是否应成为 Environment 的能力（接口/方法/事件）？
- **执行治理**：它是否应该走统一执行入口（以获得超时/权限/审计/并发控制）？
- **观测闭环**：要补哪些事件与日志，才能让 Agent/用户看见“发生了什么、为什么这样做”？
- **可复现**：是否需要记录足够上下文支持回放/重现（例如 tool args 的脱敏存档）？
- **运行形态**：CLI/Server/Test 的差异是否被 Environment 子类隔离住，而不是侵入 Agent？

如果以上问题都能在 Environment 层得到答案，Agent 核心逻辑会更稳定、更可复用。

